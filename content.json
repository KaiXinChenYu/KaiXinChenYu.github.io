[{"title":"设计模式-代理模式","date":"2017-07-14T04:10:00.000Z","path":"2017/07/14/20170714-DesignMode-Proxy/","text":"这次是DesignMode系列的第四期，是书上第七章，关于代理模式的讲解，依然使用unity来写这个实例。目的–我想改变一个UItext的值，但是我不想被UItext知道，所以我请一个代理来帮我做这件事。使用软件Visual Studio2013，Unity3D。 打开Unity3D新建项目，新建C#脚本IChangeText类： using System; using System.Collections.Generic; using System.Linq; using System.Text; //定义接口，使得我和代理都能有这个功能 interface IChangeText { string ChangeText(); } 再新建三个类分别为WantToChangeTex using System; using System.Collections; using System.Collections.Generic; //定义text，我要修改的text public class WantToChangeText { private string text; public string Text { get { return text; } set { text = value; } } } ThisIsMe类 using System; using System.Collections.Generic; using System.Linq; using System.Text; //定义我，我有改遍text的功能 public class ThisIsMe:IChangeText { //引用改变的text类 WantToChangeText wantToChangeText; //构造方法，引用代理的实例 public ThisIsMe(WantToChangeText wantToChangeText) { this.wantToChangeText = wantToChangeText; } //我间接改变UItext public string ChangeText() { wantToChangeText.Text = &quot;ThisIsMe Changed byProxy&quot;; return wantToChangeText.Text; } } ThisIsProxy类 using System; using System.Collections.Generic; using System.Linq; using System.Text; //代理类，实现接口 public class ThisIsProxy : IChangeText { private ThisIsMe me; //实例化我 public ThisIsProxy(WantToChangeText wantToChangeText) { me = new ThisIsMe(wantToChangeText); } //代理引用我的方法改变文字，并且返回 public string ChangeText() { return me.ChangeText(); } } 最后定义一个类继承MonoBeahavior，用来挂载在游戏物体上 using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class MainTool : MonoBehaviour { //在组件面板把textUI拖上去 public Text textUI; void Start() { //实例化改变的文字 WantToChangeText wantToChangeText = new WantToChangeText(); wantToChangeText.Text = textUI.text; //通过代理改变文字 ThisIsProxy proxy = new ThisIsProxy(wantToChangeText); string newText = proxy.ChangeText(); //跟新UI textUI.text = newText; } } 控制台输出显示： 代理大概就是这样一个原理，在这里我为了实现一个很小的功能，却用了大量的代码，看似很不值得，但是有的时候一个良好的代码在不知不觉中，会让你很舒服。","tags":[{"name":"DesignMode","slug":"DesignMode","permalink":"http://KaiXinChenYu.github.io/tags/DesignMode/"}]},{"title":"设计模式-装饰模式","date":"2017-05-27T03:10:01.000Z","path":"2017/05/27/20170527-DesignMode-Decorator/","text":"这次是DesignMode系列的第三期，是书上第六章，关于装饰模式的讲解，前两次一直用wpf，这次准备用unity来写这个简单实例，原理是一样的，只不过是客户端的改变。使用软件Visual Studio2013，Unity3D。 打开Unity3D新建项目，新建C#脚本Person类： using System.Collections; using System.Collections.Generic; using UnityEngine; class Person { public Person() { } private string name; public Person(string name) { this.name = name; } public virtual void Show() { Debug.Log(&quot;装扮的&quot;+name); } } 再新建服饰父类Finery，和子类Coat，Dress,Hair,Hat,Necklace,Shirt,Shoes,Skirt,Socks using System; using System.Collections.Generic; using System.Linq; using System.Text; class Finery:Person { protected Person component; public void Decorate(Person component) { this.component = component; } public override void Show() { if (component != null) { component.Show(); } } } --------------------- using System; using System.Collections.Generic; using System.Linq; using System.Text; using UnityEngine; class Coat:Finery { public override void Show() { Debug.Log(&quot;外套&quot;); base.Show(); } } --------------------- using System; using System.Collections.Generic; using System.Linq; using System.Text; using UnityEngine; class Dress:Finery { public override void Show() { Debug.Log(&quot;连衣裙&quot;); base.Show(); } } --------------------- .......... 后面的类基本类似 最后建立客户端类WearCloths，继承MonoBehavior using System; using System.Collections.Generic; using System.Linq; using System.Text; using UnityEngine; public class WearCloths :MonoBehaviour { void Start() { Person kaixin = new Person(&quot;开心&quot;); Debug.Log(&quot;\\n第一种装扮：&quot;); Coat coat = new Coat(); Hair hair = new Hair(); Skirt skirt = new Skirt(); coat.Decorate(kaixin); hair.Decorate(coat); skirt.Decorate(hair); skirt.Show(); Debug.Log(&quot;\\n第二种装扮：&quot;); Dress dress = new Dress(); Hat hat = new Hat(); Necklace necklace = new Necklace(); Shirt shirt = new Shirt(); Socks socks = new Socks(); dress.Decorate(kaixin); hat.Decorate(dress); necklace.Decorate(hat); shirt.Decorate(necklace); socks.Decorate(shirt); socks.Show(); } } 控制台输出显示：","tags":[{"name":"DesignMode","slug":"DesignMode","permalink":"http://KaiXinChenYu.github.io/tags/DesignMode/"}]},{"title":"设计模式-策略模式","date":"2017-05-23T11:10:01.000Z","path":"2017/05/23/20170523-DesignMode-StrategyMode/","text":"这次是DesignMode系列的第二期，是书上第二章，关于策略模式的讲解，用一个实例-商店收银系统来说明这个模式的优势。开发软件Visual Studio2013，WPF开发。 打开VS新建项目，选择WPF应用，客户端代码可能存在问题，水平有限，高手忽略。首先新建一个抽象类CashSuper.cs abstract class CashSuper { public abstract double AcceptCash(double money); } 再新建三个子类实现CashSuper，分别为CashNormal.cs,CashRebate.cs,CashReturn.cs class CashNormal:CashSuper { public override double AcceptCash(double money) { return money; } } class CashRebate :CashSuper { private double moneyRebate;//定义打折数量 //构造方法中，实例化时，传入打折率 public CashRebate(string moneyRebate) { this.moneyRebate = double.Parse(moneyRebate); } public override double AcceptCash(double money) { return money*moneyRebate; } } class CashReturn:CashSuper { private double moneyCondition=0.0d;//分别输入满多少返利多少 private double moneyReturn=0.0d; public CashReturn(string moneyCondition, string moneyReturn) { this.moneyCondition = double.Parse(moneyCondition); this.moneyReturn = double.Parse(moneyReturn); } public override double AcceptCash(double money) { double result = money; if (money &gt; moneyCondition) { result = money - Math.Floor(money/moneyCondition)*moneyReturn; } return result; } } 最后建立类CashContext.cs，在其中实例化对象，结合了工厂模式，客户端与后台逻辑基本分开，使得客户端只需要认识CashContext这个类就行。 class CashContext { private CashSuper cs=null; public CashContext(string type) { switch (type) { case &quot;正常收费&quot;: CashNormal cs1= new CashNormal(); cs = cs1; break; case &quot;满300返200&quot;: CashReturn cs2 = new CashReturn(&quot;300&quot;,&quot;200&quot;); cs = cs2; break; case &quot;打8折&quot;: CashRebate cs3 = new CashRebate(&quot;0.8&quot;); cs = cs3; break; } } public double GetResult(double money) { return cs.AcceptCash(money); } } 客户端代码 public partial class MainWindow : Window { private double totalPrice = 0.0d; public MainWindow() { InitializeComponent(); InitOther(); } void InitOther() { SinglePriceText.Text = &quot;0&quot;; NumberText.Text = &quot;0&quot;; TotalPriceLabel.Content = &quot;0&quot;; RecordList.Items.Clear(); if (CalcMethod.Items.Count &gt;= 1) return; CalcMethod.Items.Add(&quot;正常收费&quot;); CalcMethod.Items.Add(&quot;打8折&quot;); CalcMethod.Items.Add(&quot;满300返200&quot;); CalcMethod.SelectedIndex = 0; } private void ConfirmBtn_Click(object sender, RoutedEventArgs e) { CashContext cashContext = new CashContext(CalcMethod.SelectedItem.ToString()); double ItemTotalPrices = 0.0d; ItemTotalPrices = cashContext.GetResult(double.Parse(SinglePriceText.Text)*int.Parse(NumberText.Text)); totalPrice += ItemTotalPrices ; RecordList.Items.Add( &quot; 单价：&quot; + SinglePriceText.Text + &quot; 数量：&quot; + NumberText.Text + &quot; &quot; + CalcMethod.SelectedItem + &quot; 合计：&quot; + ItemTotalPrices+&quot;\\n&quot;); TotalPriceLabel.Content = totalPrice; } private void ResetBtn_Click(object sender, RoutedEventArgs e) { InitOther(); } } WPF界面设计 &lt;Window x:Class=&quot;CashApp.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;商场收银系统&quot; Height=&quot;450&quot; Width=&quot;425&quot;&gt; &lt;Grid&gt; &lt;TextBlock HorizontalAlignment=&quot;Left&quot; Margin=&quot;26,35,0,0&quot; TextWrapping=&quot;Wrap&quot; Text=&quot;单价：&quot; VerticalAlignment=&quot;Top&quot;/&gt; &lt;TextBlock HorizontalAlignment=&quot;Left&quot; Margin=&quot;26,65,0,0&quot; TextWrapping=&quot;Wrap&quot; Text=&quot;数量：&quot; VerticalAlignment=&quot;Top&quot;/&gt; &lt;TextBlock HorizontalAlignment=&quot;Left&quot; Margin=&quot;26,105,0,0&quot; TextWrapping=&quot;Wrap&quot; Text=&quot;计算方式：&quot; VerticalAlignment=&quot;Top&quot;/&gt; &lt;TextBlock HorizontalAlignment=&quot;Left&quot; Margin=&quot;26,332,0,0&quot; TextWrapping=&quot;Wrap&quot; Text=&quot;总计：&quot; VerticalAlignment=&quot;Top&quot;/&gt; &lt;TextBox Name=&quot;SinglePriceText&quot; HorizontalAlignment=&quot;Left&quot; Height=&quot;23&quot; Margin=&quot;67,30,0,0&quot; TextWrapping=&quot;Wrap&quot; Text=&quot;TextBox&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;196&quot; HorizontalContentAlignment=&quot;Right&quot;/&gt; &lt;TextBox Name=&quot;NumberText&quot; HorizontalAlignment=&quot;Left&quot; Height=&quot;23&quot; Margin=&quot;67,60,0,0&quot; TextWrapping=&quot;Wrap&quot; Text=&quot;TextBox&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;196&quot; HorizontalContentAlignment=&quot;Right&quot;/&gt; &lt;ListBox Name=&quot;RecordList&quot; Margin=&quot;26,151,25,119&quot; /&gt; &lt;Label Name=&quot;TotalPriceLabel&quot; Content=&quot;&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;86,332,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;165&quot; Background=&quot;{DynamicResource {x:Static SystemColors.MenuBrushKey}}&quot; HorizontalContentAlignment=&quot;Right&quot; Height=&quot;26&quot;/&gt; &lt;ComboBox Name=&quot;CalcMethod&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;101,105,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;120&quot;/&gt; &lt;Button Name=&quot;ConfirmBtn&quot; Content=&quot;确认&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;317,32,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;75&quot; Click=&quot;ConfirmBtn_Click&quot;/&gt; &lt;Button Name=&quot;ResetBtn&quot; Content=&quot;重置&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;317,62,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;75&quot; Click=&quot;ResetBtn_Click&quot;/&gt; &lt;/Grid&gt; &lt;/Window&gt; 下面是测试图： 如果需要添加新的返利方法，添加新的类就行，算法的变化，将不影响客户端。","tags":[{"name":"DesignMode","slug":"DesignMode","permalink":"http://KaiXinChenYu.github.io/tags/DesignMode/"}]},{"title":"设计模式-简单工厂模式","date":"2017-05-22T11:10:01.000Z","path":"2017/05/22/20170522-DesignMode-FactoryMode/","text":"DesignMode这个系列是我准备记录下，我最近阅读的一本书–大话设计模式，会用到书里的实例，也会加入一些自己的体会。这一期是书的第一章，关于简单工厂设计模式，具体用一个计算器的实例来简单说明这种设计模式的好处。开发软件Visual Studio2013，WPF开发。 打开VS新建项目，选择WPF应用，客户端代码肯定是有问题的，水平有限，高手忽略，主要分享的是后台的工厂模式的代码。首先新建一个父类Operation.cs public class Operation { private double _numberA = 0; private double _numberB = 0; public double NumberA { get { return _numberA; } set { _numberA = value; } } public double NumberB { get { return _numberB; } set { _numberB = value; } } public virtual double GetResult()//用于子类复写 { double result = 0; return result; } } 再新建四个子类继承自Operation，分别为OperationAdd.cs,OperationSub.cs,OperationMul.cs,OperationDiv.cs class OperationAdd:Operation { public override double GetResult() { double result = 0; result = NumberA + NumberB; return result; } } class OperationDiv:Operation { public override double GetResult() { double result = 0; if (NumberB == 0) { throw new Exception(&quot;除数不能为0&quot;); } result = NumberA/NumberB; return result; } } class OperationMul:Operation { public override double GetResult() { double result = 0; result = NumberA*NumberB; return result; } } class OperationSub:Operation { public override double GetResult() { double result = 0; result = NumberA - NumberB; return result; } } 最后建立工厂类OperationFactory.cs，用来实例化对象，使用工厂模式可以分离内部计算逻辑和客户端的耦合，客户端界面与内部计算逻辑分开。 public class OperationFactory { public static Operation CreateOperation(string operate) { Operation oper = null; switch (operate) { case &quot;+&quot;: oper = new OperationAdd(); break; case &quot;-&quot;: oper = new OperationSub(); break; case &quot;*&quot;: oper = new OperationMul(); break; case &quot;/&quot;: oper = new OperationDiv(); break; default: throw new Exception(&quot;算法不存在&quot;); break; } return oper; } } 客户端调用 Operation oper; oper = OperationFactory.CreateOperation(&quot;+&quot;); oper.NumberA = 1; oper.NumberB = 2; double result oper.GetResult(); 工厂模式到就结束了，可以调到最后看下测试图。 客户端代码MainWindow.xaml.cs，如果不按错应该没问题，按错的话。。。下面的代码可以忽略。。。 public enum OperationType { Add, Sub, Mul, Div } /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } public double numberA=0; public double numberB=0; public string operate=&quot;&quot;; public OperationType OperationType = OperationType.Add; private void Button1_Click(object sender, RoutedEventArgs e) { Label1.Content += Button1.Content.ToString(); } private void Button2_Click(object sender, RoutedEventArgs e) { Label1.Content += Button2.Content.ToString(); } private void Button3_Click(object sender, RoutedEventArgs e) { Label1.Content += Button3.Content.ToString(); } private void Button4_Click(object sender, RoutedEventArgs e) { Label1.Content += Button4.Content.ToString(); } private void Button5_Click(object sender, RoutedEventArgs e) { Label1.Content += Button5.Content.ToString(); } private void Button6_Click(object sender, RoutedEventArgs e) { Label1.Content += Button6.Content.ToString(); } private void Button7_Click(object sender, RoutedEventArgs e) { Label1.Content += Button7.Content.ToString(); } private void Button8_Click(object sender, RoutedEventArgs e) { Label1.Content += Button8.Content.ToString(); } private void Button9_Click(object sender, RoutedEventArgs e) { Label1.Content += Button9.Content.ToString(); } private void Button0_Click(object sender, RoutedEventArgs e) { Label1.Content += Button0.Content.ToString(); } private void ButtonPoint_Click(object sender, RoutedEventArgs e) { if (Label1.Content.ToString().Contains(&quot;.&quot;)) { return; } else { Label1.Content += ButtonPoint.Content.ToString(); } } private void ButtonC_Click(object sender, RoutedEventArgs e) { Label1.Content = &quot;&quot;; numberA = 0; numberB = 0; operate = &quot;&quot;; } private void ButtonAdd_Click(object sender, RoutedEventArgs e) { numberA = double.Parse(Label1.Content.ToString()); Label1.Content = &quot;&quot;; OperationType = OperationType.Add; } private void ButtonSub_Click(object sender, RoutedEventArgs e) { numberA = double.Parse(Label1.Content.ToString()); Label1.Content = &quot;&quot;; OperationType = OperationType.Sub; } private void ButtonMul_Click(object sender, RoutedEventArgs e) { numberA = double.Parse(Label1.Content.ToString()); Label1.Content = &quot;&quot;; OperationType = OperationType.Mul; } private void ButtonDiv_Click(object sender, RoutedEventArgs e) { numberA = double.Parse(Label1.Content.ToString()); Label1.Content = &quot;&quot;; OperationType = OperationType.Div; } private void ButtonResult_Click(object sender, RoutedEventArgs e) { numberB = double.Parse(Label1.Content.ToString()); Operation oper = null; switch (OperationType) { case OperationType.Add: oper = OperationFactory.CreateOperation(&quot;+&quot;); break; case OperationType.Sub: oper = OperationFactory.CreateOperation(&quot;-&quot;); break; case OperationType.Mul: oper = OperationFactory.CreateOperation(&quot;*&quot;); break; case OperationType.Div: oper = OperationFactory.CreateOperation(&quot;/&quot;); break; } oper.NumberA = this.numberA; oper.NumberB = this.numberB; double result = oper.GetResult(); Label1.Content = result; } } MainWindow.xaml下放置这么多按钮。。 &lt;Window x:Class=&quot;CalcApp.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;计算器&quot; Height=&quot;400&quot; Width=&quot;350&quot;&gt; &lt;Grid Name=&quot;CalcGrid&quot;&gt; &lt;Label Name=&quot;Label1&quot; Content=&quot;&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;10,30,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;322&quot; HorizontalContentAlignment=&quot;Right&quot; BorderThickness=&quot;0&quot;/&gt; &lt;Button Name=&quot;Button1&quot; Content=&quot;1&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;62,120,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;Button1_Click&quot; /&gt; &lt;Button Name=&quot;Button2&quot; Content=&quot;2&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;102,120,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;Button2_Click&quot; /&gt; &lt;Button Name=&quot;Button3&quot; Content=&quot;3&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;142,120,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;Button3_Click&quot; /&gt; &lt;Button Name=&quot;Button4&quot; Content=&quot;4&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;62,160,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;Button4_Click&quot; /&gt; &lt;Button Name=&quot;Button5&quot; Content=&quot;5&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;102,160,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;Button5_Click&quot; /&gt; &lt;Button Name=&quot;Button6&quot; Content=&quot;6&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;142,160,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;Button6_Click&quot; /&gt; &lt;Button Name=&quot;Button7&quot; Content=&quot;7&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;62,200,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;Button7_Click&quot; /&gt; &lt;Button Name=&quot;Button8&quot; Content=&quot;8&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;102,200,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;Button8_Click&quot; /&gt; &lt;Button Name=&quot;Button9&quot; Content=&quot;9&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;142,200,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;Button9_Click&quot; /&gt; &lt;Button Name=&quot;Button0&quot; Content=&quot;0&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;62,240,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;Button0_Click&quot; /&gt; &lt;Button Name=&quot;ButtonPoint&quot; Content=&quot;.&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;102,240,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;ButtonPoint_Click&quot; /&gt; &lt;Button Name=&quot;ButtonC&quot; Content=&quot;C&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;102,306,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;ButtonC_Click&quot; /&gt; &lt;Button Name=&quot;ButtonResult&quot; Content=&quot;=&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;142,306,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;ButtonResult_Click&quot; /&gt; &lt;Button Name=&quot;ButtonAdd&quot; Content=&quot;+&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;206,120,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;ButtonAdd_Click&quot; /&gt; &lt;Button Name=&quot;ButtonSub&quot; Content=&quot;-&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;206,160,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;ButtonSub_Click&quot; /&gt; &lt;Button Name=&quot;ButtonMul&quot; Content=&quot;*&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;206,200,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;ButtonMul_Click&quot; /&gt; &lt;Button Name=&quot;ButtonDiv&quot; Content=&quot;/&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;206,240,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; Height=&quot;30&quot; Click=&quot;ButtonDiv_Click&quot; /&gt; &lt;/Grid&gt; &lt;/Window&gt; 下面是测试图： 如果要添加其他的方法，比如开根号，sin，cos等计算方法，只需要，新加一个类，并且在工厂模式中添加对象实例化的方法就行，基本与客户端分离。","tags":[{"name":"DesignMode","slug":"DesignMode","permalink":"http://KaiXinChenYu.github.io/tags/DesignMode/"}]},{"title":"Asp.Net和Access数据库开发网站","date":"2017-04-18T01:10:01.000Z","path":"2017/04/18/20170418-WebApplication-WebSite/","text":"今天分享下，我前段时间花了一个星期，写的一个简单的网站，网址是：http://www.dongliguangyou.cn后台的数据管理基本是我开发的，前端的CSS样式借用了别人的模板。 网站内容当是一开始做这个网站的初衷是为了以后，方便分享一些东西，当时想的很多，但是实际做起来，确实碰到了很多问题，最终就做成了那个半成品。以后有空我肯定会优化那个网站，加些东西，现在基本什么都没有，数据库中就几张图片和几个作品信息。 可以在网站上找到我的联系方式 网站后台 后台可以对前台的一些数据进行管理，包括添加和删除等等，其实内部就是对数据库的增删改查。 大概就是这样吧，半成品，感觉我从来没有做过一个上的了台面的东西。有空我会发个关于使用虚拟空间和域名在网上发布网站的Blog，今天就这样吧。","tags":[{"name":"WebApplication","slug":"WebApplication","permalink":"http://KaiXinChenYu.github.io/tags/WebApplication/"}]},{"title":"使用AfterEffects替换视频天空","date":"2017-04-17T13:30:01.000Z","path":"2017/04/17/20170417-AfterEffect-SkyReplace/","text":"今天，实在事情太多了，而且最近有个开发游戏的计划，这次绝对绝对不会半路放弃了，所以就分享一个我前段时间做的关于AfterEffects的视频吧。网盘地址：http://pan.baidu.com/s/1qY57wb6","tags":[{"name":"AfterEffects","slug":"AfterEffects","permalink":"http://KaiXinChenYu.github.io/tags/AfterEffects/"}]},{"title":"Unity3D药品管理Demo","date":"2017-04-16T03:10:01.000Z","path":"2017/04/16/20170416-Unity3D-DrugManager/","text":"自己抽空，随意开发了一个，不说代码质量了，非常简单的药品管理的系统Demo，只有一部分功能，后来感觉没啥用，就放弃不搞了，简单实现了注册和登录功能，还有数据库的查找及修改。具体开发用到的软件有PhotonServer服务器框架，MySQL数据库，和Unity3D开发客户端。 Unity3D部分这部分主要是数据得显示，包括读出数据库信息显示在界面上，用户登录注册的界面显示等。更改IP可以进行局域网连接服务器，广域网没试过不知道。 PhotonServer部分这部分服务端的开发，主要通过 Visual Studio 2013 进行，在服务端连接数据库，和客户端交互。 MySQL部分这部分主要建立了几张表，用户表和药品表等。 测试部分实际测试，先打开MySQL服务，在打开photonserver服务器，最后unity中启动游戏，安卓端我也测试了下，只能说能用吧。。具体测试图如下： 大概就是一个可以简单修改数据库的软件，只不过客户端是用unity开发而已。代码比较乱，我就不分享了，网上高端物品管理系统很多很多。。","tags":[{"name":"Unity3D-Server","slug":"Unity3D-Server","permalink":"http://KaiXinChenYu.github.io/tags/Unity3D-Server/"}]},{"title":"Unity3D简易MVC框架","date":"2017-04-15T03:10:01.000Z","path":"2017/04/15/20170415-Unity3D-MVC/","text":"一个用于Unity3D游戏开发的简易MVC框架，用于开发一些小型的游戏足够了，调理很清晰。框架来源是泰课在线上NickyMa讲师的保卫萝卜中的MVC框架，个人感觉非常不错的一篇教程，有兴趣可以去看看，网址： http://www.taikr.com/course/308 ，我只是学习了一下，写这篇Blog也是为了再理一下思路和记录下来，方便以后使用。 Unity3D中的操作具体MVC的原理我就不讲了，Google一下，会有很多的介绍。直接讲代码书写，首先打开Unity3D，创建1个文件夹命名为MVC，再创建三个脚本，分别命名为Model，Controller，View。在新建一个脚本命名为MVC，用于管理Model，Controller，View这三个类，包括之间的事件发送，获取和注册。 Model： using System; using System.Collections.Generic; using System.Linq; using System.Text; public abstract class Model { public abstract string Name { get; } protected void SendEvent(string eventName, object data = null) { MVC.SendEvent(eventName,data); } } View： using System; using System.Collections.Generic; using System.Text; using UnityEngine; public abstract class View : MonoBehaviour { //视图标识 public abstract string Name { get; } //关心事件列表 public List&lt;string&gt; AttationEvents =new List&lt;string&gt;(); //事件处理函数 public abstract void HandleEvent(string eventName, object data); //获取模型 protected Model GetModel&lt;T&gt;() where T : Model { return MVC.GetModel&lt;T&gt;(); } //发送消息 protected void SendEvent(string eventName,object data=null) { MVC.SendEvent(eventName,data); } } Controller： using System; using System.Collections.Generic; using System.Linq; using System.Text; public abstract class Controller { //获取模型 protected Model GetModel&lt;T&gt;() where T : Model { return MVC.GetModel&lt;T&gt;(); } //获取视图 protected View GetView&lt;T&gt;() where T : View { return MVC.GetView&lt;T&gt;(); } protected void RegisterModel(Model model) { MVC.RegisterModel(model); } protected void RegisterView(View view) { MVC.RegisterView(view); } protected void RegisterController(string eventName, Type controllerType) { MVC.RegisterController(eventName,controllerType); } //处理系统消息 public abstract void Execute(object data); } MVC： using System; using System.Collections.Generic; using System.Linq; using System.Text; public static class MVC { //存储MVC public static Dictionary&lt;string,Model&gt; Models =new Dictionary&lt;string, Model&gt;();//名字--模型 public static Dictionary&lt;string, View&gt; Views = new Dictionary&lt;string, View&gt;();//名字--视图 public static Dictionary&lt;string, Type&gt; CommandMap = new Dictionary&lt;string, Type&gt;();//事件名字--控制器类型 //注册 public static void RegisterModel(Model model) { Models[model.Name] = model; } public static void RegisterView(View view) { Views[view.Name] = view; } public static void RegisterController(string eventName, Type controllerType) { CommandMap[eventName] = controllerType; } //获取 public static Model GetModel&lt;T&gt;() where T:Model { foreach (Model m in Models.Values) { if (m is T) { return m; } } return null; } public static View GetView&lt;T&gt;() where T:View { foreach (View v in Views.Values) { if (v is T) { return v; } } return null; } //发送事件 public static void SendEvent(string eventName, object data =null) { //控制器响应时间 if (CommandMap.ContainsKey(eventName)) { Type t = CommandMap[eventName]; Controller c = Activator.CreateInstance(t) as Controller; //控制器执行 c.Execute(data); } //视图响应事件 foreach (View v in Views.Values) { if (v.AttationEvents.Contains((eventName))) { //视图响应事件 v.HandleEvent(eventName,data); } } } } 代码的书写基本按照标题上的那张图片，今天就这么多吧，等有空，我做个Demo，讲下如何使用这个简单的MVC框架。","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://KaiXinChenYu.github.io/tags/Unity3D/"}]},{"title":"Unity3D单例模板--通过继承简单实现单例","date":"2017-04-14T04:10:01.000Z","path":"2017/04/14/20170414-Unity3D-Singleton/","text":"一个单例的模板，通过继承这个工具类，在Unity中轻松实现单例，不过这个单例模板还是存在一些问题，比如不适合多线程。具体较为完整的单例模式介绍，可以参考这篇文章下面这篇简书上的文章，关于Java的单例 http://www.jianshu.com/p/eb30a388c5fc ，文章将单例模式讲解的很清楚，C#的单例模式也基本差不多。 Unity3D中的操作首先打开Unity3D，创建一个类命名为Singleton,意思是单例。打开这个类填写如下代码： Singleton： using System; using UnityEngine; //定义泛型T，限定T继承自MonoBehaviour public abstract class Singleton&lt;T&gt;:MonoBehaviour where T : MonoBehaviour { private static T m_instance = null; public static T Instance { get { return m_instance; } } //调用Awake()方法，定义为虚方法，方便子类如果也需要Awake（）方法，可以复写 protected virtual void Awake() { m_instance = this as T; } } 单例模板使用方法，创建一个C#脚本，名称任意，我命名为Test，具体如下： Test： using System; using UnityEngine; public class Test : Singleton&lt;Test&gt; { //可以简单定义个方法或者属性，就可以在外部通过 //Test.Instance.属性或者方法 进行访问了 } 只是一个简单的单例模式，但是感觉在开发中，单例模式用的非常多。虽然这个模板还是存在一些不足，不过在一般情况下，肯定是够用了，而且还是很方便的，只要直接继承就行。","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://KaiXinChenYu.github.io/tags/Unity3D/"}]},{"title":"Photoshop动作——学习ps的GoodMethod","date":"2017-04-13T15:00:01.000Z","path":"2017/04/13/20170413-Photoshop-Action/","text":"主要是使用ps动作窗口，快速实现自己需要的效果，百度下也能找到相关类似的教程，我这主要是自己总结下，提升下自己，文章最后会分享一些我个人在网上收集的ps动作。 Ps中的操作首先打开ps，我这用的是PhotoshopCS6，使用快捷键Alt+F9或者在菜单栏的窗口（W）下拉菜单中，找到动作菜单，点击打开。在动作面板中右上方，小三角点击，选择加入动作，动作格式为.atn格式。如下图： 点击动作前的小三角，可以显示整个动作所使用的操作，可以通过一些动作，学习一些处理过程。 点击选择需要的动作，点下方的小三角，来使用动作，之后ps自动执行操作，快速的形成了各种不同的效果。 下面是一些网上的动作，百度云盘链接：链接：http://pan.baidu.com/s/1mh8MMVY 今天有点忙，只能简单简单写一下Blog了。","tags":[{"name":"Photoshop","slug":"Photoshop","permalink":"http://KaiXinChenYu.github.io/tags/Photoshop/"}]},{"title":"Unity3D简易UI框架（工具类）","date":"2017-04-12T04:35:00.000Z","path":"2017/04/12/20170412-Unity3D-UIFramework/","text":"自己参照网上的UI框架，简单改了下，并且用到了昨天的txt文本读取。只做了个简单的测试，可能存在一些问题。 工具类代码首先在Unity中新建3个C#脚本，分别命名为GameRoot，UIBase，UIManager，命名看自己喜好吧。分别如下： UIBase： using System.Collections; using System.Collections.Generic; using UnityEngine; public class UIBase : MonoBehaviour { /// &lt;summary&gt; /// 显示界面 /// &lt;/summary&gt; public virtual void DoOnEntering() { } /// &lt;summary&gt; /// 暂停界面 /// &lt;/summary&gt; public virtual void DoOnPausing() { } /// &lt;summary&gt; /// 继续界面 /// &lt;/summary&gt; public virtual void DoOnResuming() { } /// &lt;summary&gt; /// 关闭界面 /// &lt;/summary&gt; public virtual void DoOnExiting() { } } UIManager： using System.Collections; using System.Collections.Generic; using UnityEngine; public class UIManager { /// &lt;summary&gt; /// 单例模式，初始化对象 /// &lt;/summary&gt; private static UIManager _instance; public static UIManager Instance { get { if (_instance == null) { _instance = new UIManager(); } return _instance; } } //构造函数中初始化，读取UI文件夹下的所有prefabs private UIManager() { LoadAllUIPrefabs(); } /// &lt;summary&gt; /// 存放UI面板的栈 /// &lt;/summary&gt; private Stack&lt;UIBase&gt; UIPanelStack; /// &lt;summary&gt; /// 保存所有的面板 /// &lt;/summary&gt; private Dictionary&lt;string, UIBase&gt; UIPanelDict; /// &lt;summary&gt; /// 根据名字保存面板的prefab /// &lt;/summary&gt; private Dictionary&lt;string, GameObject&gt; UIPrefabDict =new Dictionary&lt;string, GameObject&gt;(); /// &lt;summary&gt; /// UI路径 /// &lt;/summary&gt; private string ResourceDir = &quot;UI&quot;; /// &lt;summary&gt; /// 把页面入栈--把页面显示在界面上 /// &lt;/summary&gt; public void PushPanel(string UIPanelName) { if (UIPanelStack == null) UIPanelStack = new Stack&lt;UIBase&gt;(); //判断一下栈里面是否有页面 if (UIPanelStack.Count &gt; 0) { UIBase topPanel = UIPanelStack.Peek(); topPanel.DoOnPausing(); } UIBase panel = GetPanel(UIPanelName); panel.DoOnEntering(); UIPanelStack.Push(panel); } /// &lt;summary&gt; /// 出栈 ，把页面从界面上移除 /// &lt;/summary&gt; public void PopPanel() { if (UIPanelStack == null) UIPanelStack = new Stack&lt;UIBase&gt;(); if (UIPanelStack.Count == 0) return; //关闭栈顶页面的显示 UIBase topPanel = UIPanelStack.Pop(); topPanel.DoOnExiting(); if (UIPanelStack.Count &gt; 0) { UIBase topPanel2 = UIPanelStack.Peek(); topPanel2.DoOnResuming(); } } /// &lt;summary&gt; /// 根据面板类型 得到实例化的面板 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private UIBase GetPanel(string UIPanelName) { if (UIPanelDict == null) { UIPanelDict = new Dictionary&lt;string, UIBase&gt;(); } UIBase panel; UIPanelDict.TryGetValue(UIPanelName, out panel); //如果找不到，就根据prefab去实例化面板 if (panel == null) { GameObject UIPrefab = UIPrefabDict[UIPanelName]; GameObject instPanel = GameObject.Instantiate&lt;GameObject&gt;(UIPrefab); instPanel.name = UIPanelName; UIBase UIBase = instPanel.GetComponent&lt;UIBase&gt;(); UIPanelDict.Add(UIPanelName, UIBase); return UIBase; } else { return panel; } } //加载prefab的方法，存到字典中 public void LoadAllUIPrefabs() { TextAsset ta = Resources.Load&lt;TextAsset&gt;(&quot;UIPanelInfo&quot;); string allInfo = ta.text; string[] lineInfoArray = allInfo.Split(&apos;\\n&apos;); foreach (string lineInfo in lineInfoArray) { string[] itemInfoArray = lineInfo.Split(&apos;,&apos;); foreach (string item in itemInfoArray) { string UIPath = ResourceDir + &quot;/&quot; + item; GameObject UIPrefab = Resources.Load&lt;GameObject&gt;(UIPath); if (UIPrefab) UIPrefabDict.Add(item, UIPrefab); } } } } GameRoot： using System.Collections; using System.Collections.Generic; using UnityEngine; public class GameRoot : MonoBehaviour { /// &lt;summary&gt; /// 启动初始界面,挂在游戏物体之上 /// &lt;/summary&gt; void Start () { UIManager.Instance.PushPanel(&quot;OptionPanel&quot;); } } 使用方法简单测试Demo：在Assets文件夹下新建Resources，Scripts，Scenes和UIFramework文件夹，Rescources文件夹下新建UI文件夹和UIPanelInfo.txt文件（UTF-8格式）。Hierarchy面板新建两个Canvas，改名为OptionPanel和StartPanel，在各自下面分别再建一个Panel，改改颜色大小之类的。OptionPanel下新建一个Start按钮。再新建两个脚本StartUI和OptionUI，都继承自UIBase，之后就可以复写父类的四个方法，分别可以控制UI面板的各个状态。OptionUI在添加一个点击事件–事件内容为push一个StartPanel，之后给Start按钮添加点击事件。 txt文本填写StartPanel，OptionPanel具体格式和昨天的一样，也可以选择用json之类的 上面只是试了下，因为blog实在写不了太多，太废时间了，具体怎么用，我可能会出个视频，也加强下自己对这个工具类的理解。其实如果UI面板比较少的话，没必要用框架，不过用了的话，整体确实清晰很多，也方便管理。 今天，到这了。","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://KaiXinChenYu.github.io/tags/Unity3D/"}]},{"title":"Unity3D数据读取--简单Txt格式读取","date":"2017-04-11T00:35:00.000Z","path":"2017/04/11/20170411-Unity3D-DataLoad/","text":"今天主要讲下我在使用Unity3D过程中，读取文件数据时一些浅显的经验，肯定有不少问题。 游戏开发过程中，如果是单机游戏，一般不包含数据库，这样导致稍微复杂的游戏将会包含大量的数据信息，包括物品，剧情，技能，人物信息等，这些数据得存储一般都会以一个外部文件进行存储，可以是Json，Xml，Excel，Txt等，这样方便管理游戏中大量的数据。这些数据将在运行游戏的时候进行读取。如果只是读取数据，那么Txt文本是不错的选择，因为Unity源生对txt支持较好，可以在组件上直接拖入。而要像数据库一样，对这些数据进行增删改查的话Json和Xml是更好的选择。 这次主要讲下读取txt文本。 数据读取步骤1.素材准备先准备一个txt文件，我这用了一个Excel文档（来源：金庸群侠传X Mod编辑器）转成txt，因为个人感觉用excel管理数据，清晰明了，如果能直接读取当然更好，但是unity本身对其的支持不是很好，虽然也可以通过插件读取，但是或多或少还有些问题。excel表先另存为转成逗号分隔符的csv格式，然后直接强制转成txt。附：excel文件地址 http://pan.baidu.com/s/1geZvqUJ 2.Unity中操作1.Hierarchy面板新建一个空的游戏物体，起名GameManager。2.Project面板新建四个文件夹备用，Scripts文件夹下，新建C#脚本InventoryInfoLoadManager和Inventory脚本，名称随意。3.将脚本挂载到GameManager上。 3.读取代码打开脚本Inventory，只读取一部分信息，编写如下代码： using System.Collections; using System.Collections.Generic; using UnityEngine; public class Inventory { //属性定义 private string name; private string des; private string talent; //封装 public string Name { get { return name; } set { name = value; } } public string Des { get { return des; } set { des = value; } } public string Talent { get { return talent; } set { talent = value; } } } 打开脚本InventoryInfoLoadManager脚本，编写如下代码： using System.Collections; using System.Collections.Generic; using UnityEngine; public class InventoryInfoLoadManager : MonoBehaviour { //单例模式 //public static InventoryInfoLoadManager _instance; //也可以用Resources.Load读取，我这就直接通过Inspector面板拖入 public TextAsset inventoryInfo; //List集合存储所有物品 public List&lt;Inventory&gt; list= new List&lt;Inventory&gt;(); //void Awake() //{ // _instance = this; //} //Start方法中读取物品信息 void Start() { ReadInfo(); foreach (Inventory inventory in list) { print(inventory.Name);//输出到控制台测试 } } //信息读取方法 void ReadInfo() { string allInfo = inventoryInfo.text; string[] lineInfoArray = allInfo.Split(&apos;\\n&apos;); foreach (string lineInfo in lineInfoArray) { string[] itemInfoArray = lineInfo.Split(&apos;,&apos;); if (itemInfoArray[0] == &quot;物品名&quot;) { } else { string name = itemInfoArray[0]; string des = itemInfoArray[1]; string talent = itemInfoArray[3]; Inventory it= new Inventory(); it.Name = name; it.Des = des; it.Talent = talent; list.Add(it); } } } } 写完代码把txt文件拖到脚本InventoryInfoLoadManager上，确保txt文本没有多余空格，且是utf-8格式，之后在控制台就能显示读取数据。到这就结束了，下面是我自己继续将信息显示到游戏物体之上，方法不好。 4.界面显示首先将InventoryInfoLoadManager中注释的单例模式取消注释，再新建两个类，InventoryManager和InventoryItem，Hierarchy面板新建grid（grid上添加GridLayouGroup脚本）用来存放物品，和item物体（item物体添加InventoryItem脚本）用来存放物品信息，get按钮添加点击事件，InventoryManager拖到GameManager游戏物体上具体如下图： InventoryItem脚本如下： using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class InventoryItem : MonoBehaviour { //UI相关 public Text name; public Text des; public Text talent; public void UpdateInfo(string name,string des,string talent) { this.name.text = name; this.des.text = des; this.talent.text = talent; } } InventoryManager脚本如下： using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class InventoryManager : MonoBehaviour { //网格游戏物体 public GameObject grid; //prefab public GameObject inventoryItemPrefab; //获取list中所有物品 private List&lt;Inventory&gt; list; public void OnClickLoadInventory() { list = InventoryInfoLoadManager._instance.list; foreach (Inventory inventory in list) { inventoryItemPrefab.GetComponent&lt;InventoryItem&gt;().UpdateInfo(inventory.Name,inventory.Des,inventory.Talent); GameObject iip = GameObject.Instantiate(inventoryItemPrefab) as GameObject; iip.transform.parent = grid.transform; } } } Inspector面板如下图： 最终结果图： 写完了，好艰难。。","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://KaiXinChenYu.github.io/tags/Unity3D/"}]},{"title":"技术之路从此开始","date":"2017-04-10T11:05:00.000Z","path":"2017/04/10/20170410-Diary-Beginning/","text":"第一次写博客，写的随意了一点，主要讲下我的经历，和今后的目标。 不知不觉从大四的时候接触java，认识到什么是真正的编程，到现在已经2年多了，而我依然还是在技术门外徘徊。本科化工自动化毕业后选择考研，然后调剂到造纸专业，当时不懂，总觉得研究生总是比本科要好吧。然后刚进去的一年真的是煎熬，什么都不懂，一切从头做起。而在这样的一个环境下，我却偏执的想做一个程序员，当第一个“Hello World”显示在屏幕上时，当第一个APK在自己手上诞生时，当第一个网站发布出来时，当第一个游戏应用在自己手上玩起来时等等，一切的一切充满了成就感，哪怕只能自己一个人分享。不可自拔的喜欢上这个二进制的世界，这个能创造一切的世界，不起眼的你，也许正用代码操控着一个世界。 不知道是不是对现实的逃避，我非常不喜欢的现在的专业，不说有没有前途，虽然造纸确实差点，但是个人感觉专业到一定的程度，每个行业都是有发展的。就说我的专业，研究生基本都是做实验，做实验肯定要化学药品，各种有毒。所以我学的可以说很不认真，大部分的时间我都用来自学一些软件，包括平面设计，三维建模和游戏制作等，也一直看编程相关的书，现在可能比较熟悉C#吧。我不知道这样做对不对，但是我的目标很明确，保证毕业的情况下，自学我喜欢的，哪怕毕业后两边都没学好，也不后悔，相信每个人心中都有一个梦想，我也有个————想开发一个完全由我原创的游戏（这其中艰难程度不多说）。 这个博客是因为加了一个群，群主提到了用hexo和github搭建博客网站，然后提到了stormzhang这个行业内高手。之后我去加了AndroidDeveloper这个微信公众号，看了stormzhang的一些文章，才发现自己与外界交流太少了，只靠自己看视频看书自学肯定不够，我在程序的门外徘徊太久了。不知道为什么，感觉这两天收获真的很大。也因为以上的原因，我决定申请个github账号，并且做一个属于自己的博客。我前段时间也买过虚拟空间和域名，并且用.net写过一个个人网站（很简陋，没啥功能，还借用了别人模板），发布到网上，有时间我还是想把博客和自己的个人网站充实起来。 定了个一年内的目标：第一，每周尽可能做三期视频，主要关于PS，AE，Unity3D的，可能算是教程？或者自己的学习之路吧。视频暂时只放到个人网站，之后看做的好再想要不要发布。第二，每天尽可能发一个博客，哪怕只是生活的琐事（尽量保证技术相关）。第三，把游戏制作，真正提上日程吧，总是三天打鱼两天晒网，永远不可能制作出游戏，更别说成功的游戏艺术。最后，每天花点时间学学英语，背背单词，或者还有其他的，反正尽可能充实自己吧。 不知道我能不能坚持下去！！","tags":[{"name":"成长之路","slug":"成长之路","permalink":"http://KaiXinChenYu.github.io/tags/成长之路/"}]}]